#include <stdio.h>
#include <stdlib.h>
#include "pico/stdlib.h"
#include "hardware/adc.h"
#include "hardware/i2c.h"
#include "hardware/pwm.h"
#include "inc/ssd1306.h"
#include "inc/font.h"

// Definições de pinos e constantes
#define PORTA_I2C i2c1
#define PINO_SDA 14
#define PINO_SCL 15
#define ENDERECO_DISPLAY 0x3C
#define PINO_JOYSTICK_X 27  // Pino do eixo X do joystick
#define PINO_JOYSTICK_Y 26  // Pino do eixo Y do joystick
#define PINO_BOTAO_JOYSTICK 22  // Pino do botão do joystick
#define PINO_BOTAO_A 5  // Pino do botão A
#define PINO_LED_VERMELHO 13  // Pino do LED vermelho
#define PINO_LED_VERDE 11  // Pino do LED verde
#define PINO_LED_AZUL 12  // Pino do LED azul

#define LARGURA_DISPLAY 128
#define ALTURA_DISPLAY 64
#define TAMANHO_QUADRADO 8  // Tamanho do quadrado que se move no display
#define VALOR_CENTRAL_JOYSTICK 2048  // Valor central do joystick

// Variáveis globais
volatile bool pwm_ativado = true;  // Controla se o PWM está ativado ou não
volatile bool estado_led_verde = false;  // Estado do LED verde
volatile bool botao_joystick_pressionado = false;  // Estado do botão do joystick
volatile int estilo_borda = 0;  // Estilo da borda (0, 1, 2 ou 3)

// Função para tratar interrupções dos botões (debouncing incluso)
void tratar_interrupcao_botao(uint gpio, uint32_t eventos) {
    static absolute_time_t ultimo_tempo = {0};
    
    // Debouncing: só executa se passaram mais de 200ms desde a última interrupção
    if (absolute_time_diff_us(ultimo_tempo, get_absolute_time()) > 200000) {
        if (gpio == PINO_BOTAO_JOYSTICK) {
            estado_led_verde = !estado_led_verde;  // Alterna o estado do LED verde
            gpio_put(PINO_LED_VERDE, estado_led_verde);  // Atualiza o LED verde
            estilo_borda = (estilo_borda + 1) % 4;  // Alterna entre 4 estilos de borda
        } else if (gpio == PINO_BOTAO_A) {
            pwm_ativado = !pwm_ativado;  // Alterna o estado do PWM
        }
        ultimo_tempo = get_absolute_time();  // Atualiza o tempo da última interrupção
    }
}

// Função para configurar o PWM em um pino
void configurar_pwm(uint pino) {
    gpio_set_function(pino, GPIO_FUNC_PWM);  // Define o pino como função PWM
    uint slice_num = pwm_gpio_to_slice_num(pino);  // Obtém o slice do PWM
    pwm_set_wrap(slice_num, 4095);  // Define o valor máximo do PWM
    pwm_set_chan_level(slice_num, pwm_gpio_to_channel(pino), 0);  // Inicia com duty cycle 0
    pwm_set_enabled(slice_num, true);  // Habilita o PWM
}

int main() {
    stdio_init_all();  // Inicializa a comunicação serial (para debug)

    // Inicialização do I2C para o display
    i2c_init(PORTA_I2C, 400 * 1000);  // Configura o I2C a 400 kHz
    gpio_set_function(PINO_SDA, GPIO_FUNC_I2C);  // Define o pino SDA como I2C
    gpio_set_function(PINO_SCL, GPIO_FUNC_I2C);  // Define o pino SCL como I2C
    gpio_pull_up(PINO_SDA);  // Habilita pull-up no pino SDA
    gpio_pull_up(PINO_SCL);  // Habilita pull-up no pino SCL

    // Inicialização do display SSD1306
    ssd1306_t display;
    ssd1306_init(&display, LARGURA_DISPLAY, ALTURA_DISPLAY, false, ENDERECO_DISPLAY, PORTA_I2C);
    ssd1306_config(&display);  // Configura o display
    ssd1306_send_data(&display);  // Envia os dados para o display

    // Limpa o display
    ssd1306_fill(&display, false);
    ssd1306_send_data(&display);

    // Inicialização do ADC para o joystick
    adc_init();
    adc_gpio_init(PINO_JOYSTICK_X);  // Configura o pino do eixo X como entrada analógica
    adc_gpio_init(PINO_JOYSTICK_Y);  // Configura o pino do eixo Y como entrada analógica

    // Configuração dos botões com interrupções
    gpio_init(PINO_BOTAO_JOYSTICK);
    gpio_set_dir(PINO_BOTAO_JOYSTICK, GPIO_IN);
    gpio_pull_up(PINO_BOTAO_JOYSTICK);
    gpio_set_irq_enabled_with_callback(PINO_BOTAO_JOYSTICK, GPIO_IRQ_EDGE_FALL, true, &tratar_interrupcao_botao);

    gpio_init(PINO_BOTAO_A);
    gpio_set_dir(PINO_BOTAO_A, GPIO_IN);
    gpio_pull_up(PINO_BOTAO_A);
    gpio_set_irq_enabled_with_callback(PINO_BOTAO_A, GPIO_IRQ_EDGE_FALL, true, &tratar_interrupcao_botao);

    // Configuração dos LEDs RGB
    gpio_init(PINO_LED_VERMELHO);
    gpio_set_dir(PINO_LED_VERMELHO, GPIO_OUT);
    gpio_put(PINO_LED_VERMELHO, 0);  // Inicia com o LED vermelho apagado

    gpio_init(PINO_LED_VERDE);
    gpio_set_dir(PINO_LED_VERDE, GPIO_OUT);
    gpio_put(PINO_LED_VERDE, 0);  // Inicia com o LED verde apagado

    gpio_init(PINO_LED_AZUL);
    gpio_set_dir(PINO_LED_AZUL, GPIO_OUT);
    gpio_put(PINO_LED_AZUL, 0);  // Inicia com o LED azul apagado

    // Configuração do PWM para os LEDs vermelho e azul
    configurar_pwm(PINO_LED_VERMELHO);
    configurar_pwm(PINO_LED_AZUL);

    // Posição inicial do quadrado no display (centralizado)
    int x = (LARGURA_DISPLAY - TAMANHO_QUADRADO) / 2;  // x = (128 - 8) / 2
    int y = (ALTURA_DISPLAY - TAMANHO_QUADRADO) / 2;   // y = (64 - 8) / 2

    while (true) {
        // Leitura dos valores do joystick
        adc_select_input(0);  // Seleciona o eixo X
        uint16_t valor_x = adc_read();
        adc_select_input(1);  // Seleciona o eixo Y
        uint16_t valor_y = adc_read();

        // Controle do PWM para os LEDs RGB
        if (pwm_ativado) {
            // LED vermelho: controlado pelo eixo X
            if (valor_x != VALOR_CENTRAL_JOYSTICK) {
                pwm_set_gpio_level(PINO_LED_VERMELHO, abs(valor_x - VALOR_CENTRAL_JOYSTICK));
            } else {
                pwm_set_gpio_level(PINO_LED_VERMELHO, 0);  // Apaga o LED vermelho no centro
            }

            // LED azul: controlado pelo eixo Y
            if (valor_y != VALOR_CENTRAL_JOYSTICK) {
                pwm_set_gpio_level(PINO_LED_AZUL, abs(valor_y - VALOR_CENTRAL_JOYSTICK));
            } else {
                pwm_set_gpio_level(PINO_LED_AZUL, 0);  // Apaga o LED azul no centro
            }
        } else {
            pwm_set_gpio_level(PINO_LED_VERMELHO, 0);  // Desliga o LED vermelho
            pwm_set_gpio_level(PINO_LED_AZUL, 0);  // Desliga o LED azul
        }

        // Atualização da posição do quadrado no display
        x = (LARGURA_DISPLAY - TAMANHO_QUADRADO) * valor_x / 4095;
        y = (ALTURA_DISPLAY - TAMANHO_QUADRADO) * valor_y / 4095;

        // Desenha o quadrado e atualiza o display
        ssd1306_fill(&display, false);  // Limpa o display
        ssd1306_rect(&display, x, y, TAMANHO_QUADRADO, TAMANHO_QUADRADO, true, false);

        // Aplica o estilo da borda conforme o estado atual
        switch (estilo_borda) {
            case 0:
                // Estilo 1: borda simples
                ssd1306_rect(&display, 3, 3, LARGURA_DISPLAY - 6, ALTURA_DISPLAY - 6, true, false);
                break;
            case 1:
                // Estilo 2: borda dupla
                ssd1306_rect(&display, 3, 3, LARGURA_DISPLAY - 6, ALTURA_DISPLAY - 6, true, false);
                ssd1306_rect(&display, 2, 2, LARGURA_DISPLAY - 4, ALTURA_DISPLAY - 4, true, false);
                break;
            case 2:
                // Estilo 3: borda tripla
                ssd1306_rect(&display, 3, 3, LARGURA_DISPLAY - 6, ALTURA_DISPLAY - 6, true, false);
                ssd1306_rect(&display, 2, 2, LARGURA_DISPLAY - 4, ALTURA_DISPLAY - 4, true, false);
                ssd1306_rect(&display, 1, 1, LARGURA_DISPLAY - 2, ALTURA_DISPLAY - 2, true, false);
                break;
            case 3:
                // Estilo 4: borda tracejada (usando retângulos pequenos)
                for (int i = 0; i < LARGURA_DISPLAY; i += 4) {
                    ssd1306_rect(&display, i, 0, 2, 2, true, false);  // Linha superior
                    ssd1306_rect(&display, i, ALTURA_DISPLAY - 2, 2, 2, true, false);  // Linha inferior
                }
                for (int i = 0; i < ALTURA_DISPLAY; i += 4) {
                    ssd1306_rect(&display, 0, i, 2, 2, true, false);  // Linha esquerda
                    ssd1306_rect(&display, LARGURA_DISPLAY - 2, i, 2, 2, true, false);  // Linha direita
                }
                break;
        }

        ssd1306_send_data(&display);  // Atualiza o display

        sleep_ms(100);  // Pequeno delay para evitar sobrecarga
    }
}